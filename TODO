
Remote environment stuff:

  Need ability to send data to a Flume stream.
  -- FlowInfo should include the output name for a flow
    -- CmdLineClient's formatting of the header line for FlowInfo lists should be
       in FlowInfo.java
  -- ExecEnv & friends need ability to set Flume node name for an anonymous flow,
     revoke name, assign new name, etc.
  -- When we bind a name to a flow, we should do the metadata ops to list that as a stream
  -- unbinding a name from a flow should drop the stream of the same name.
  -- Add ability to pull from these into further statements.
    -- Need ability to specify a stream is full of avro formatted data
    -- Need EventParser that handles Avro.
  -- Operations like \w <streamName> should call a method that resolves a name to
     a flowId, and then calls watch() on the flowId.

  ===============================================

  ... test what happens with multiple clients listening to the same flow
  and what happens when one ^C's, etc.

  Problematic behavior
    client connects, sets up a flow
    data comes back
    client ^C
    send another message into the flow. it goes nowhere (expected)
    -- but no err reported back to the server about the lost output.
    connect another client
    watch the same flow
    send another message into the flow. 
    -- server sees an error writing to the first client (expected) and closes
    -- .... server does NOT send the message to the new client.
    send a 3rd message into the flow.
    -- seen by the new client.


    - The 2nd message should be delivered to the 2nd client.
    - The 1st message should have caused the error on the server side.

Joins:
  I don't know that the various calls to streamSymbol.getName() are actually
  the correct name here -- I think we want the user's alias to get its way
  into the various source types.

  SelectStmt should support WINDOW clauses at the end.
  ^-- need to eval them to WindowSpecs and store these bindings for use in joinedsrc
      evaluation to hashjoinnodes.


  .. what happens if we use the same stream alias in two different subtrees of
  a compound select stmt?
  
  SELECT ... FROM
      ((SELECT x FROM f JOIN g) AS s1)
  JOIN
      ((SELECT x FROM h AS f JOIN g) AS s2)

  Specifically w.r.t. concerns over the lists returned by getSourceNames().. does
  this stop at the SELECT level, or does it recursively gather?
  I think we're ok for SELECT/JOIN... but I don't know how we will do for predicate
  push-down later..

Expressions:
  - Refine user_sel rule (or TypeChecker) so that it cannot accept identifier names that
    end in "_". (We need these for internal field identifiers in avro.)


Technical debt:
  - Write more unit tests as outlined at the bottom of TestSelect.
  - Need more tests in TestTypeChecker; see TODO in comments.
  - LocalEnv / LocalEnvThread is full of SelectableQueue<Object> because we put
    both EventWrappers and ControlOps in different threads. We then typecase on
    what we get back. Would be nice if we could create some common interface
    with a dispatch() / delegate()-and-handle() model to clean up the big
    typecase in the run() method...
  - Select.join() will consult its underlying Selectables in a stable order,
    which means we might starve later Selectables in the list. We need to
    perturb this to ensure fairness.

SQL Features (in rough priority order):
  - Aggregation and aggregate functions
  - Filtering (HAVING)
  - LIMIT (within a window?)
  - [windowed] ORDER BY -- how does this work for overlapping windows?

Aggregation:

  - Implement COUNT(*), COUNT(foo).
  - Implement windowing.


Bugs:

  - Quitting is very slow due to the Flume shutdown. Can we improve this?
    ... it also emits a scary looking error message, that we should suppress for
    hygeine's sake.

Features:

  - Need ability to run remote physical plan on a set of configured nodes.

  - EventParser names/implementations should be accessed through the BuiltInSymbolTable.
  - Need a MapFunc API to allow 1-to-many transformations.


Optimizations:

  - ProjectionNode instances with identical input and output schemata should be removed.
  - ProjectionNode immediately after NamedSource should be fused.
  -- longer term: projection (and filtering) should be pushed up into previous
     FlowElements, when we use DAG tiling.
  - AvroEventWrapper could be improved by deserializing only the fields necessary
    for a given combined set of FE's in advance, knowing the input, output, and also
    internal-use schemas. (We may take in <int, string> and emit <int, string> but
    only query the int component; we could project onto that as we deserialize, and
    then save ourselves the trouble on the string.)
  - Expr.eval() should go by the wayside; what we really want is each Expr contributing
    a set of three-addr codes to a set of basic blocks that corresponds to the set of
    expressions the user wants emitted; then we can perform further optimization on
    this like common subexpression elimination, etc. We need to define a RTL that can
    handle all this. Then if our opcodes are things like AddIntInt, AddFloatFloat, etc.,
    we can dispense with the stored Type instances inside Exprs being required at
    run time.

