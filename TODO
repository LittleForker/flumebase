

Joins:
  When using symbols in IdentifierExpr, if we can't find a symbol, we need to warn
  that it may be due to an ambiguous alias. (Search for a symbol ending with ".foo"; if
  found, then it's an ambiguous resolution error.)

  TypeChecker and all visitor patterns need WindowSpec, RangeSpec, WindowDef.
  ^... maybe done?
  SelectStmt should support WINDOW clauses at the end.
  ^-- need to eval them to timespans and store these bindings for use in joinedsrc
      evaluation to hashjoinnodes.
  SelectStmt should support JoinedSource as a source type..
  Need to define the JoinedSource AST element and do all that jazz.
  .... this needs to return a HashJoinNode and associated etc.
  Need to define JOIN Node, Element.
  Need to work JoinNode/JoinElement into the graph.
  Need to handle column name aliasing, etc.


Expressions:
  - Refine user_sel rule (or TypeChecker) so that it cannot accept identifier names that
    end in "_". (We need these for internal field identifiers in avro.)

Rewriting the coupling between FlowElements in the LocalEnvironment:

  The current unbounded-buffer coupling between FE's is unnecessary and poor form.
  Instead, we should have a much better set of coupling options:
  - FE classes should have static methods advertising whether event generation is
    performed in-thread (e.g., projection), or in an external thread (e.g., the sources).
  - When we build FE's, we should consider the number of input and output FEs that will
    be joined to a given FE.
    -- if we are in-thread and have a single downstream, we should directly call it
       with no buffering.
    -- if we are out-of-thread, we should buffer into target queues for the downstream FE.
    -- if we have multiple downstreams, we should deliver to them with direct calls.

  Event delivery queues should be receipt queues, not delivery queues. They're wired
  backwards. Such queues should be bounded, to allow cross-thread backpressure.

  Need to rewrite a BoundedQueue implementation that implements a "Selectable" interface,
  then write a "Select" class that can be notified when any dependency isSelectable().
  Use the 'reverse wait object' pattern also used by joinFlow().


Technical debt surrounding tests:
  - Write more unit tests as outlined at the bottom of TestSelect.
  - Need more tests in TestTypeChecker; see TODO in comments.

SQL Features (in rough priority order):
  - Aggregation and aggregate functions
  - Join
  - Filtering (HAVING)
  - LIMIT
  - ORDER BY

Aggregation:

  - Implement COUNT(*), COUNT(foo).
  - Implement windowing.


Bugs:
  - It is possible in the LocalEnvironment that the control queue is filled with
    externally-placed entries. If the LocalEnvThread itself must add entries to
    the control queue (e.g., because of a CompletionEvent posted by
    FlowElementContext.notifyCompletion()), it might deadlock on itself. We need
    a data structure that allows bounded puts from other threads, but the internal
    thread is allowed to override the limit.

  - Flume is super-chatty when you start it up locally. We should squash its logs,
    unless we're in debug mode.

  - Quitting is very slow due to the Flume shutdown. Can we improve this?
    ... it also emits a scary looking error message, that we should suppress for
    hygeine's sake.

Features:

  - Need ability to create a remote physical plan
  -- Need ability to run remote physical plan on a set of configured nodes.
  - Need a DROP FLOW operation
  - Need SHOW FLOWS operation
  - Need ExecEnvironment.joinFlow(flowId, timeout)
  - Need ability to auto-connect to a remote Flume resource.

  - EventParser names/implementations should be accessed through the BuiltInSymbolTable.
  - Need a MapFunc API to allow 1-to-many transformations.


Optimizations:

  - ProjectionNode instances with identical input and output schemata should be removed.
  - ProjectionNode immediately after NamedSource should be fused.
  -- longer term: projection (and filtering) should be pushed up into previous
     FlowElements, when we use DAG tiling.
  - AvroEventWrapper could be improved by deserializing only the fields necessary
    for a given combined set of FE's in advance, knowing the input, output, and also
    internal-use schemas. (We may take in <int, string> and emit <int, string> but
    only query the int component; we could project onto that as we deserialize, and
    then save ourselves the trouble on the string.)
  - Expr.eval() should go by the wayside; what we really want is each Expr contributing
    a set of three-addr codes to a set of basic blocks that corresponds to the set of
    expressions the user wants emitted; then we can perform further optimization on
    this like common subexpression elimination, etc. We need to define a RTL that can
    handle all this. Then if our opcodes are things like AddIntInt, AddFloatFloat, etc.,
    we can dispense with the stored Type instances inside Exprs being required at
    run time.

