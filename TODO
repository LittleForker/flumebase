
Next on the list:

  Write more unit tests as outlined at the bottom of TestSelect.


Expressions:
  - The expression parse layer should actually go before the projection layer.
    expressions rely on the original field names. 

      things to test:
        select a, a+1 from x
        select a as b, a+1 from x; // ok
        select a as b, b+1 from x; // should fail.
        select a, b from x;
        select a as b, b as a from x;
        select a as b, b as c from x;



      try all the expr types by themselves too

  - select 1 - b from foo <-- cannot coerce from INT to NULLABLE INT?
    b-1 works fine....
    create stream foo(a string, b int) from local file "/home/aaron/foo.txt";
  - TypedField -- is displayName always equal to mName?
  - Need to handle scalar fns
    -- need a BuiltInSymbolTable to hold some functions
    -- need function API
    -- need to add functions like LENGTH, CURRENT_TIMESTAMP(), etc.
    ---- reflect these into BuiltInSymbolTable by walking the package.
  - IS NULL and IS NOT NULL are unary expressions, not binary.
  - Need more tests in TestTypeChecker; see TODO in comments.
  - Refine user_sel rule (or TypeChecker) so that it cannot accept identifier names that
    end in "_". (We need these for internal field identifiers in avro.)

Rewriting the coupling between FlowElements in the LocalEnvironment:

  The current unbounded-buffer coupling between FE's is unnecessary and poor form.
  Instead, we should have a much better set of coupling options:
  - FE classes should have static methods advertising whether event generation is
    performed in-thread (e.g., projection), or in an external thread (e.g., the sources).
  - When we build FE's, we should consider the number of input and output FEs that will
    be joined to a given FE.
    -- if we are in-thread and have a single downstream, we should directly call it
       with no buffering.
    -- if we are out-of-thread, we should buffer into target queues for the downstream FE.
    -- if we have multiple downstreams, we should deliver to them with direct calls.

  Event delivery queues should be receipt queues, not delivery queues. They're wired
  backwards. Such queues should be bounded, to allow cross-thread backpressure.

  Need to rewrite a BoundedQueue implementation that implements a "Selectable" interface,
  then write a "Select" class that can be notified when any dependency isSelectable().
  Use the 'reverse wait object' pattern also used by joinFlow().



SQL Features (in rough priority order):
  - General expression parsing
  -- scalar functions
  - Filtering (WHERE)
  - Aggregation and aggregate functions
  - Join
  - Filtering (HAVING)
  - LIMIT
  - ORDER BY


Expression Parsing and Function Application:

  Need to be able to handle SELECT a, b, c, 2 * d, 1 + 1 FROM foo;
  Need to be able to handle SELECT LENGTH(a) FROM foo;

  Modify SELECT to take an expression_list instead of a field_list.
  An expression_list is a list of expressions
  expressions include:
    a single field
    "*" / all-fields
    fn(e, e, e...)
    e1 bop e2
    (e)

  bop ::= * / + - % == != > < <= >=

Aggregation:

  - Implement COUNT(*), COUNT(foo).
  - Implement windowing.


Bugs:
  - It is possible in the LocalEnvironment that the control queue is filled with
    externally-placed entries. If the LocalEnvThread itself must add entries to
    the control queue (e.g., because of a CompletionEvent posted by
    FlowElementContext.notifyCompletion()), it might deadlock on itself. We need
    a data structure that allows bounded puts from other threads, but the internal
    thread is allowed to override the limit.

  - DelimitedEventParser: if the expected type of a column is a union (e.g., because it is  
    nullable), we need to put the parsed entity into a generic union object of the appropriate
    sub-schema. (ArrayIndexOutOfBoundsException gets thrown in avro somewhere...
    this seems to be a problem in the Flume-based source, but not file-based?

    CREATE STREAM foo (a STRING) FROM LOCAL SOURCE "text(\"/var/log/messages\")"; // no good
    SELECT a FROM foo; // returns nothing;

    CREATE STREAM foo (a STRING NOT NULL) FROM LOCAL SOURCE "text(\"/var/log/messages\")"; // ok!
    SELECT a FROM foo; // returns msgs;

    CREATE STREAM foo (a STRING, b INT) FROM LOCAL FILE "/home/aaron/foo.txt";
    SELECT a, b FROM foo; // OK (!?!)


  - Flume is super-chatty when you start it up locally. We should squash its logs,
    unless we're in debug mode.

  - We have precious few automated end-to-end tests. This is hugely problematic.
  - Quitting is very slow due to the Flume shutdown. Can we improve this?
    ... it also emits a scary looking error message, that we should suppress for
    hygeine's sake.


Features:

  - Need ability to create a remote physical plan
  -- Need ability to run remote physical plan on a set of configured nodes.
  - Need a DROP FLOW operation
  - Need SHOW FLOWS operation
  - Need ability to auto-connect to a remote Flume resource.

  - Need to pick different delimiters for DelimitedEventParser.
  - Need to pick different EventParser implementations for different streams.

Optimizations:

  - ProjectionNode instances with identical input and output schemata should be removed.
  - ProjectionNode immediately after NamedSource should be fused.
  -- longer term: projection (and filtering) should be pushed up into previous
     FlowElements, when we use DAG tiling.
  - AvroEventWrapper could be improved by deserializing only the fields necessary
    for a given combined set of FE's in advance, knowing the input, output, and also
    internal-use schemas. (We may take in <int, string> and emit <int, string> but
    only query the int component; we could project onto that as we deserialize, and
    then save ourselves the trouble on the string.)
  - Expr.eval() should go by the wayside; what we really want is each Expr contributing
    a set of three-addr codes to a set of basic blocks that corresponds to the set of
    expressions the user wants emitted; then we can perform further optimization on
    this like common subexpression elimination, etc. We need to define a RTL that can
    handle all this. Then if our opcodes are things like AddIntInt, AddFloatFloat, etc.,
    we can dispense with the stored Type instances inside Exprs being required at
    run time.

