

  Test NULL string and integer fields in a SELECT stmt from memory.
  Test FormatSpec options; set a different delimiter, null.sequence.
  Implement IS NULL, IS NOT NULL. 


Expressions:
  - IS NULL and IS NOT NULL are unary expressions, not binary.
  - Refine user_sel rule (or TypeChecker) so that it cannot accept identifier names that
    end in "_". (We need these for internal field identifiers in avro.)

Rewriting the coupling between FlowElements in the LocalEnvironment:

  The current unbounded-buffer coupling between FE's is unnecessary and poor form.
  Instead, we should have a much better set of coupling options:
  - FE classes should have static methods advertising whether event generation is
    performed in-thread (e.g., projection), or in an external thread (e.g., the sources).
  - When we build FE's, we should consider the number of input and output FEs that will
    be joined to a given FE.
    -- if we are in-thread and have a single downstream, we should directly call it
       with no buffering.
    -- if we are out-of-thread, we should buffer into target queues for the downstream FE.
    -- if we have multiple downstreams, we should deliver to them with direct calls.

  Event delivery queues should be receipt queues, not delivery queues. They're wired
  backwards. Such queues should be bounded, to allow cross-thread backpressure.

  Need to rewrite a BoundedQueue implementation that implements a "Selectable" interface,
  then write a "Select" class that can be notified when any dependency isSelectable().
  Use the 'reverse wait object' pattern also used by joinFlow().


Technical debt surrounding tests:
  - Write more unit tests as outlined at the bottom of TestSelect.
  - Need more tests in TestTypeChecker; see TODO in comments.

SQL Features (in rough priority order):
  - Aggregation and aggregate functions
  - Join
  - Filtering (HAVING)
  - LIMIT
  - ORDER BY

Aggregation:

  - Implement COUNT(*), COUNT(foo).
  - Implement windowing.


Bugs:
  - It is possible in the LocalEnvironment that the control queue is filled with
    externally-placed entries. If the LocalEnvThread itself must add entries to
    the control queue (e.g., because of a CompletionEvent posted by
    FlowElementContext.notifyCompletion()), it might deadlock on itself. We need
    a data structure that allows bounded puts from other threads, but the internal
    thread is allowed to override the limit.

  - Flume is super-chatty when you start it up locally. We should squash its logs,
    unless we're in debug mode.

  - Quitting is very slow due to the Flume shutdown. Can we improve this?
    ... it also emits a scary looking error message, that we should suppress for
    hygeine's sake.

  - If you put a null in a column, and it's declared as "X NOT NULL", this causes
    a NPE and a crash. Instead, the entire record should be dropped.

Features:

  - Need ability to create a remote physical plan
  -- Need ability to run remote physical plan on a set of configured nodes.
  - Need a DROP FLOW operation
  - Need SHOW FLOWS operation
  - Need ExecEnvironment.joinFlow(flowId, timeout)
  - Need ability to auto-connect to a remote Flume resource.

  - FnCallExpr currently casts all arguments to the expected types before
    calling fn.eval(). Some functions (e.g., pow(x,y)) can take any numeric
    type and operate on it, and should not be pre-cast. We need the ability to
    specify that a function call should delay coercion; or else perhaps allow
    the function to specify that an argument is of Type.getType(TYPE_CLASS_NUMERIC)
    and so long as the argument type is in the type class, accept it without further
    conversion.
  - EventParser names/implementations should be accessed through the BuiltInSymbolTable.

Optimizations:

  - ProjectionNode instances with identical input and output schemata should be removed.
  - ProjectionNode immediately after NamedSource should be fused.
  -- longer term: projection (and filtering) should be pushed up into previous
     FlowElements, when we use DAG tiling.
  - AvroEventWrapper could be improved by deserializing only the fields necessary
    for a given combined set of FE's in advance, knowing the input, output, and also
    internal-use schemas. (We may take in <int, string> and emit <int, string> but
    only query the int component; we could project onto that as we deserialize, and
    then save ourselves the trouble on the string.)
  - Expr.eval() should go by the wayside; what we really want is each Expr contributing
    a set of three-addr codes to a set of basic blocks that corresponds to the set of
    expressions the user wants emitted; then we can perform further optimization on
    this like common subexpression elimination, etc. We need to define a RTL that can
    handle all this. Then if our opcodes are things like AddIntInt, AddFloatFloat, etc.,
    we can dispense with the stored Type instances inside Exprs being required at
    run time.

